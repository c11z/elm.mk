# Elm.mk

A minimal Makefile to work on [Elm](http://elm-lang.org) projects that require external js and css. It requires
a working Elm installation.

## Philosophy

The main goal of this boilerplate is to **minimise the needs for external dependencies** while providing an effective
development environment. This means that it tries as much as possible to bundle pre-compiled utilities to accomplish the needed tasks.

## Features

- [x] Cross-platform (OS X + Linux 64bit - help with Windows would be nice)
- [x] Elm [StartApp](http://package.elm-lang.org/packages/evancz/start-app/2.0.2/) installation
- [x] Project scaffold generation
- [x] Elm compilation with warnings
- [x] Scss compilation via [Wellington](https://github.com/wellington/wellington)
- [x] Watch and recompile via [modd](https://github.com/cortesi/modd)
- [x] Live reload via [devd](https://github.com/cortesi/devd)
- [x] File generators based on templates
- [x] Support for unit testing (optional)

## Setup from scratch

- `mkdir my_new_project && cd my_new_project`
- `curl -o elm.mk https://raw.githubusercontent.com/cloud8421/elm.mk/master/elm.mk`
- `make -f elm.mk install`

This will generate the needed folder structure and files. Note that at the end of `make install`, you're left with
an empty `Makefile` that includes `elm.mk`, so that you can extend it for your needs and/or override its behaviour.

## Project workflow

Main commands:

- `make install`: installs all needed dependencies
- `make`: compiles the project into `build`
- `make server`: serves the build folder with a local http server
- `make watch`: starts the file watcher and the http server, recompiling files on save
- `make clean`: deletes all compiled files
- `make help`: shows all main tasks

### Components structure

Elm.mk encourages splitting your application into smaller applications.

For example, let's say you have a **auth** application and a **user** one.

You can define your `COMPILE_TARGETS` variable as follows:

```
COMPILE_TARGETS := build/auth/main.js build/auth/interop.js \
                   build/auth/main.css build/auth/index.html \
                   build/users/main.js build/users/interop.js \
                   build/users/main.css build/users/index.html
```

Every application is made of 4 components:

- an `html` page: its source sits in `pages`. The build process simply copies the source file, so that `pages/users/index.html` generates `build/users/index.html`;
- a `css` style file: its source sits in `styles`. The build process compiles the `.scss` source, so that `styles/users/main.scss` generates `build/users/main.scss`;
- a `interop` JavaScript file, whose purpose is to bootstrap the Elm application and handle all interop-related code. Note that the name `interop.js` (irrespectively of the containing directory) is what tells Elm.mk that it's an interop file and not a compiled Elm file. The build process copies the interop js file from `interop/`, so that `interop/users/app.js` generates `build/users/interop.js`;
- a `js` file generated by Elm. The build process compiles Elm source code from `src`, so that `src/Users/Main.elm` generates `build/users/main.js`.

Note that this layout represents a full fledged stand-alone application, which isn't always what you need (e.g. you may have a single `html` file, a single `css` file and multiple Elm applications). What Elm.mk gives you is a way to specify **which files you want to be generated**, knowing how to generate them in the first place.

Some guidelines:

- Files generated into `build` should not be edited manually
- All other files can be modified;
- Dependencies between `scss` files are handled via regular `@import` scss directives;
- Dependencies between `elm` files are handled via the Elm dependency resolution system (see `elm-package.json` for all paths that are already included);
- The path resolution system can be deeply nested, e.g. `build/admin/users/main.js` resolves to `src/Admin/Users/Main.elm`;
- It's recommended to use absolute urls, e.g. if you need to refer `build/users/main.css` from `build/users/index.html`, use `<link rel="stylesheet" href="/users/main.css">`, as this makes it easy to deploy the built files and to serve them for development.

It may also be worth checking out the documentation for the software used in this boilerplate (like Devd or Modd), as they provide functionality that it's not covered here.

## Extending install targets

Install targets represent tooling dependencies that your project has.

For example you may wanna add support for image compression using a hypothetical tool called `compress`, whose binary you can download.

In your `Makefile`, you can add a `CUSTOM_INSTALL_TARGETS` definition, which will be picked up by `make install`:

```
CUSTOM_INSTALL_TARGETS := bin/compress

bin/compress:
  curl -o $@ http://example.com/compress
```

## Testing

It's possible to add support for unit testing via <https://github.com/rtfeldman/node-elm-test>.

To do that, it's enough to call `make test`, which will install the needed dependencies. Note that this requires Node to be installed.

Calling `make test` again will rerun the test suite.

## FAQs/Comments

#### I don't think this should use X, Y is a better fit.
As long as it's easy to install in portable format (i.e. download in the project folder and run), please feel free to state the case for a replacement

#### Why is feature X missing?
Probably because I haven't thought about it.

#### Why Make?
Make is ubiquitous, mostly pre-installed (or very easy to install) and language-agnostic. It takes some time to adjust to it, but it's fast, effective and modular.

#### This make task is not optimal, it's much better if you change it like this!
Please submit a PR, I'm happy to learn

#### I don't know Make, but I'd like to help. Where can I learn more?
Smashing Magazine has a [very good introduction](https://www.smashingmagazine.com/2015/10/building-web-applications-with-make/) and there are [good books](http://shop.oreilly.com/product/9780596006105.do) out there. They mostly focus on usage with C, but they should work out fine.
